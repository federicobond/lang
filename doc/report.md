lang
====

## Introduction

This document describes the design of the lang language. lang is an imperative
language for the [Java Virtual Machine][jvm] (from now on, the JVM). It has a
clean syntax inspired by languages like [Scala][scala] and [Kotlin][kotlin].

## Design Considerations

The AST class design is heavily inspired by the [JRuby][jruby] project.

## Grammar description

## Difficulties encountered

One of the first difficulties we found was setting everything up correctly. The
[JFlex][jflex] and [Java CUP][java_cup] projects are quite old and while they
have received constant updates, the documentation is lacking in many areas, with
obsolete code examples.

The other main obstacle was coming up with a suitable workflow for adding new
language features. Adding integration tests early on made it possible to work
on the codebase with confidence that we would not break any previous
functionality.

## Preliminary research

After some research we found out that the [Jasmin][jasmin] library suggested in
class was not the best choice for implementing the language, since it was no
longer maintained and lacked useful abstraction for generating the required code
from the Abstract Syntax Tree.

## Supporting libraries

The project was very conservative in its use of libraries. For generating the
lexer and parser code we used [JFlex][jflex] and [Java CUP][java_cup].

To generate bytecode from the AST returned by the parser, we chose to use the
[ASM][asm] library.

## Notes on the workflow

We found a very useful workflow for adding the bytecode implementations for
each node. We would write a Java implementation of the syntax construct we were
implementing and look at the generated bytecode (the IntelliJ IDEA IDE has a
very useful bytecode view that is accessed from the View menu). The one thing
that we had to be careful for was to keep the JVM from optimizing constant
expressions. In most cases, assigning the expression components to variables is
enough. So, instead of writing:

    if (true && false) {
        ...
    }

We would write:

    boolean a = true;
    boolean b = false;
    if (a && b) {
        ...
    }

The Java bytecode instruction listings found in Wikipedia also proved very useful, since
it details the contents of the stack before and after the instruction.

# Optimization passes

We designed an optimization pass that traverses the AST and simplifies nodes based on compile-time
evaluation of constant expressions. One example of such case is an `if` statement whose condition
can be determined to be always true. The optimization pass discards any `else` clauses and replaces
the `if` node with a block. Thus, the compiled code will not contain unnecessary jumps.

The code for this optimization can be found in `ConstantFoldingVisitor` class.

## Benchmarking

We compared the code against equivalent Java and Scala implementations.

## Future extensions

Thorough the project we kept a `TODO.md` file with ideas for things we could
add to the language. Some of them landed on the final release, but others
demanded too much time and are listed below as future extensions.

## Conclusion

We found out that implementing a programming language on top of the JVM is both approachable and fun.
The supporting libraries are mature and provide useful abstractions for simplifying the work.

We learned about JVM internals that are rarely exposed most Java programmer and gained a better
understanding of the Java platform.


[jvm]: https://en.wikipedia.org/wiki/Java_virtual_machine
[scala]: http://www.scala-lang.org/
[kotlin]: http://kotlinlang.org/
[jflex]: http://jflex.de/
[java_cup]: http://www2.cs.tum.edu/projects/cup/
[asm]: http://asm.ow2.org/
[jasmin]: http://jasmin.sourceforge.net/
[wiki-bytecode]: https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings
[jruby]: http://jruby.org/

