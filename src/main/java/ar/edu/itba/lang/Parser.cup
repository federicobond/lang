package ar.edu.itba.lang;

import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;
import ar.edu.itba.lang.ast.*;

parser code {:
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

terminal PLUS, TIMES, MINUS, UMINUS, DIVIDE;
terminal LEFT_PAREN, RIGHT_PAREN;
terminal IF, ELSE, WHILE, OPEN_BRACKET, CLOSE_BRACKET;
terminal IDENTIFIER;
terminal COMMA;
terminal TRUE, FALSE;

terminal T;
terminal Integer INT;
terminal Double REAL;
terminal String STRING;

non terminal ListNode StatementList;
non terminal Node Statement;
non terminal Node Expression;
non terminal Node Literal;
non terminal Node Call;
non terminal ListNode Args;
non terminal Node If;
non terminal Node While;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UMINUS;


StatementList ::= Statement:s StatementList:xs          {: RESULT = xs; xs.add(s); :}
                |                                       {: RESULT = new BlockNode(); :}
                ;

Statement     ::= If:i                                  {: RESULT = i; :}
                | While:w                               {: RESULT = w; :}
                | Call:c                                {: RESULT = c; :}
                ;

Expression    ::= Expression:e1 PLUS  Expression:e2     {: RESULT = new AddNode(e1, e2); :}
                | Expression:e1 MINUS Expression:e2     {: RESULT = new SubstractNode(e1, e2); :}
                | Expression:e1 TIMES Expression:e2     {: RESULT = new MultiplyNode(e1, e2); :}
                | Expression:e1 DIVIDE Expression:e2    {: RESULT = new DivideNode(e1, e2); :}
                | MINUS Expression:e                    {: RESULT = new NegateNode(e); :}
                  %prec UMINUS
                | LEFT_PAREN Expression:e RIGHT_PAREN   {: RESULT = e; :}
                | Literal:l                             {: RESULT = l; :}
                ;

If            ::= IF Expression:condition OPEN_BRACKET StatementList:thenBody CLOSE_BRACKET
                    {: RESULT = new IfNode(condition, thenBody, null); :}
                | IF Expression:condition OPEN_BRACKET StatementList:thenBody CLOSE_BRACKET
                  ELSE OPEN_BRACKET StatementList:elseBody CLOSE_BRACKET
                    {: RESULT = new IfNode(condition, thenBody, elseBody); :}
                ;

While         ::= WHILE Expression:condition OPEN_BRACKET StatementList:body CLOSE_BRACKET
                    {: RESULT = new WhileNode(condition, body); :};

Call          ::= IDENTIFIER:i LEFT_PAREN Args:a RIGHT_PAREN
                    {: RESULT = new CallNode((String)i, a); :};

Args          ::= Expression:e COMMA Args:l             {: RESULT = l; l.add(e); :}
                | Expression:e                          {: RESULT = new ArgsNode(); RESULT.add(e); :}
                |                                       {: RESULT = new ArgsNode(); :}
                ;

Literal       ::= INT:n                                 {: RESULT = new LiteralNode(n); :}
                | REAL:d                                {: RESULT = new LiteralNode(d); :}
                | STRING:s                              {: RESULT = new LiteralNode(s); :}
                | TRUE                                  {: RESULT = new TrueNode(); :}
                | FALSE                                 {: RESULT = new FalseNode(); :}
                ;
